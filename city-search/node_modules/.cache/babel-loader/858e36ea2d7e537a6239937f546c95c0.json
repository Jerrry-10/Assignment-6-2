{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyPatch = applyPatch;\nexports.applyPatches = applyPatches;\n/*istanbul ignore end*/\n\nvar\n/*istanbul ignore start*/\n_parse = require(\"./parse\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_distanceIterator = _interopRequireDefault(require(\"../util/distance-iterator\"))\n/*istanbul ignore end*/\n;\n/*istanbul ignore start*/\n\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/*istanbul ignore end*/\n\n\nfunction applyPatch(source, uniDiff) {\n  /*istanbul ignore start*/\n  var\n  /*istanbul ignore end*/\n  options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff =\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _parse\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    parsePatch\n    /*istanbul ignore end*/\n    )(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent)\n  /*istanbul ignore start*/\n  {\n    return (\n      /*istanbul ignore end*/\n      line === patchContent\n    );\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator =\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _distanceIterator\n    /*istanbul ignore end*/\n    [\n    /*istanbul ignore start*/\n    \"default\"\n    /*istanbul ignore end*/\n    ])(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff =\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _parse\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    parsePatch\n    /*istanbul ignore end*/\n    )(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}","map":{"version":3,"sources":["C:\\Users\\Jerry\\node_modules\\diff\\src\\patch\\apply.js"],"names":["options","uniDiff","Array","lines","source","delimiters","hunks","compareLine","line","patchContent","errorCount","fuzzFactor","minLine","offset","j","hunk","operation","content","toPos","i","maxLine","localOffset","iterator","hunkFits","diffOffset","delimiter","previousOperation","removeEOFNL","addEOFNL","_k","currentIndex","index","updatedContent","applyPatch","processIndex"],"mappings":"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","sourcesContent":["import {parsePatch} from './parse';\nimport distanceIterator from '../util/distance-iterator';\n\nexport function applyPatch(source, uniDiff, options = {}) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  }\n\n  // Apply the diff to the input\n  let lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n\n      compareLine = options.compareLine || ((lineNumber, line, operation, patchContent) => line === patchContent),\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n\n      removeEOFNL,\n      addEOFNL;\n\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n  function hunkFits(hunk, toPos) {\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line);\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n        toPos++;\n      }\n    }\n\n    return true;\n  }\n\n  // Search best fit offsets for each hunk based on the previous ones\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n\n    let iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    }\n\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  }\n\n  // Apply patch hunks\n  let diffOffset = 0;\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        toPos = hunk.oldStart + hunk.offset + diffOffset - 1;\n    diffOffset += hunk.newLines - hunk.oldLines;\n\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line),\n          delimiter = hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        toPos++;\n      } else if (operation === '-') {\n        lines.splice(toPos, 1);\n        delimiters.splice(toPos, 1);\n      /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(toPos, 0, content);\n        delimiters.splice(toPos, 0, delimiter);\n        toPos++;\n      } else if (operation === '\\\\') {\n        let previousOperation = hunk.lines[j - 1] ? hunk.lines[j - 1][0] : null;\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  }\n\n  // Handle EOFNL insertion/removal\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n  for (let _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n  return lines.join('');\n}\n\n// Wrapper that supports multiple file patches via callbacks.\nexport function applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  let currentIndex = 0;\n  function processIndex() {\n    let index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function(err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      let updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function(err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}\n"]},"metadata":{},"sourceType":"script"}