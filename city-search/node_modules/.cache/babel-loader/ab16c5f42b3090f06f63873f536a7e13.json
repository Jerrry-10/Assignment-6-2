{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = Diff;\n/*istanbul ignore end*/\n\nfunction Diff() {}\n\nDiff.prototype = {\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  diff: function diff(oldString, newString) {\n    /*istanbul ignore start*/\n    var\n    /*istanbul ignore end*/\n    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath =\n        /*istanbul ignore start*/\n        void 0\n        /*istanbul ignore end*/\n        ;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          // This should not happen, but we want to be safe.\n\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  castInput: function castInput(value) {\n    return value;\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}","map":{"version":3,"sources":["C:\\Users\\Jerry\\node_modules\\diff\\src\\diff\\base.js"],"names":["Diff","diff","options","callback","self","setTimeout","oldString","newString","newLen","oldLen","editLength","maxEditLength","bestPath","newPos","components","oldPos","done","value","count","length","diagonalPath","basePath","addPath","removePath","canAdd","canRemove","clonePath","buildValues","execEditLength","exec","ret","pushComponent","last","added","removed","extractCommon","commonCount","equals","left","right","removeEmpty","i","array","castInput","tokenize","join","chars","componentPos","componentLen","component","oldValue","tmp","lastComponent","path"],"mappings":"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","sourcesContent":["export default function Diff() {}\n\nDiff.prototype = {\n  diff(oldString, newString, options = {}) {\n    let callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n\n    let self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function() { callback(undefined, value); }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n\n    let newLen = newString.length, oldLen = oldString.length;\n    let editLength = 1;\n    let maxEditLength = newLen + oldLen;\n    let bestPath = [{ newPos: -1, components: [] }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{value: this.join(newString), count: newString.length}]);\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        let basePath;\n        let addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        let canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n    if (callback) {\n      (function exec() {\n        setTimeout(function() {\n          // This should not happen, but we want to be safe.\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      }());\n    } else {\n      while (editLength <= maxEditLength) {\n        let ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  pushComponent(components, added, removed) {\n    let last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\n    } else {\n      components.push({count: 1, added: added, removed: removed });\n    }\n  },\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({count: commonCount});\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n\n  equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right\n        || (this.options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n    }\n  },\n  removeEmpty(array) {\n    let ret = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput(value) {\n    return value;\n  },\n  tokenize(value) {\n    return value.split('');\n  },\n  join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  let componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        let value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function(value, i) {\n          let oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let lastComponent = components[componentLen - 1];\n  if (componentLen > 1\n      && typeof lastComponent.value === 'string'\n      && (lastComponent.added || lastComponent.removed)\n      && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) };\n}\n"]},"metadata":{},"sourceType":"script"}