{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcLineCount = calcLineCount;\nexports.merge = merge;\n/*istanbul ignore end*/\n\nvar\n/*istanbul ignore start*/\n_create = require(\"./create\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_parse = require(\"./parse\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_array = require(\"../util/array\")\n/*istanbul ignore end*/\n;\n/*istanbul ignore start*/\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/*istanbul ignore end*/\n\n\nfunction calcLineCount(hunk) {\n  /*istanbul ignore start*/\n  var _calcOldNewLineCount =\n  /*istanbul ignore end*/\n  calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return (\n        /*istanbul ignore start*/\n        (0,\n        /*istanbul ignore end*/\n\n        /*istanbul ignore start*/\n        _parse\n        /*istanbul ignore end*/\n        .\n        /*istanbul ignore start*/\n        parsePatch\n        /*istanbul ignore end*/\n        )(param)[0]\n      );\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return (\n      /*istanbul ignore start*/\n      (0,\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      _create\n      /*istanbul ignore end*/\n      .\n      /*istanbul ignore start*/\n      structuredPatch\n      /*istanbul ignore end*/\n      )(undefined, undefined, base, param)\n    );\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      /*istanbul ignore start*/\n      var _hunk$lines;\n      /*istanbul ignore end*/\n      // Mine inserted\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      /*istanbul ignore start*/\n      var _hunk$lines2;\n      /*istanbul ignore end*/\n      // Theirs inserted\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines2 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines2\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _array\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    arrayStartsWith\n    /*istanbul ignore end*/\n    )(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      /*istanbul ignore start*/\n      var _hunk$lines3;\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines3 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines3\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      myChanges));\n\n      return;\n    } else if (\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _array\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    arrayStartsWith\n    /*istanbul ignore end*/\n    )(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      /*istanbul ignore start*/\n      var _hunk$lines4;\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines4 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines4\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      theirChanges));\n\n      return;\n    }\n  } else if (\n  /*istanbul ignore start*/\n  (0,\n  /*istanbul ignore end*/\n\n  /*istanbul ignore start*/\n  _array\n  /*istanbul ignore end*/\n  .\n  /*istanbul ignore start*/\n  arrayEqual\n  /*istanbul ignore end*/\n  )(myChanges, theirChanges)) {\n    /*istanbul ignore start*/\n    var _hunk$lines5;\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n\n    (_hunk$lines5 =\n    /*istanbul ignore end*/\n    hunk.lines).push.apply(\n    /*istanbul ignore start*/\n    _hunk$lines5\n    /*istanbul ignore end*/\n    ,\n    /*istanbul ignore start*/\n    _toConsumableArray(\n    /*istanbul ignore end*/\n    myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    /*istanbul ignore start*/\n    var _hunk$lines6;\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n\n    (_hunk$lines6 =\n    /*istanbul ignore end*/\n    hunk.lines).push.apply(\n    /*istanbul ignore start*/\n    _hunk$lines6\n    /*istanbul ignore end*/\n    ,\n    /*istanbul ignore start*/\n    _toConsumableArray(\n    /*istanbul ignore end*/\n    theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}","map":{"version":3,"sources":["C:\\Users\\Jerry\\node_modules\\diff\\src\\patch\\merge.js"],"names":["oldLines","newLines","calcOldNewLineCount","hunk","mine","loadPatch","theirs","ret","fileNameChanged","selectField","mineIndex","theirsIndex","mineOffset","theirsOffset","mineCurrent","oldStart","Infinity","theirsCurrent","hunkBefore","cloneHunk","mergedHunk","Math","newStart","lines","mergeLines","patch","index","test","check","offset","their","insertLeading","theirCurrent","mutualChange","collectChange","removal","conflict","insertTrailing","calcLineCount","myChanges","theirChanges","allRemoves","skipRemoveSuperset","collectContext","swap","insert","line","operation","state","changes","merged","matchIndex","contextChanges","conflicted","matchChanges","change","match","prev","i","changeContent","removeChanges","myCount","theirCount"],"mappings":"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","sourcesContent":["import {structuredPatch} from './create';\nimport {parsePatch} from './parse';\n\nimport {arrayEqual, arrayStartsWith} from '../util/array';\n\nexport function calcLineCount(hunk) {\n  const {oldLines, newLines} = calcOldNewLineCount(hunk.lines);\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nexport function merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n\n  let ret = {};\n\n  // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n\n  let mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    let mineCurrent = mine.hunks[mineIndex] || {oldStart: Infinity},\n        theirsCurrent = theirs.hunks[theirsIndex] || {oldStart: Infinity};\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      let mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if ((/^@@/m).test(param) || ((/^Index:/m).test(param))) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {mine, theirs};\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart\n    && (test.oldStart + test.oldLines) < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  let mine = {offset: mineOffset, lines: mineLines, index: 0},\n      their = {offset: theirOffset, lines: theirLines, index: 0};\n\n  // Handle any leading content\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine);\n\n  // Now in the overlap content. Scan through and select the best changes from each.\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    let mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+')\n        && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      // Mine inserted\n      hunk.lines.push(... collectChange(mine));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      // Theirs inserted\n      hunk.lines.push(... collectChange(their));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  }\n\n  // Now push anything that may be remaining\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges)\n        && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      hunk.lines.push(... myChanges);\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges)\n        && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      hunk.lines.push(... theirChanges);\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    hunk.lines.push(... myChanges);\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    hunk.lines.push(... theirChanges.merged);\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  let ret = [],\n      operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    let line = state.lines[state.index];\n\n    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  let changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n  while (matchIndex < matchChanges.length\n        && state.index < state.lines.length) {\n    let change = state.lines[state.index],\n        match = matchChanges[matchIndex];\n\n    // Once we've hit our add, then we are done\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n\n    merged.push(match);\n    matchIndex++;\n\n    // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+'\n      && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged,\n    changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function(prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (let i = 0; i < delta; i++) {\n    let changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  let oldLines = 0;\n  let newLines = 0;\n\n  lines.forEach(function(line) {\n    if (typeof line !== 'string') {\n      let myCount = calcOldNewLineCount(line.mine);\n      let theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n\n  return {oldLines, newLines};\n}\n"]},"metadata":{},"sourceType":"script"}