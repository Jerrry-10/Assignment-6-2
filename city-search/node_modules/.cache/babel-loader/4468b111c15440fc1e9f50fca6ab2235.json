{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.structuredPatch = structuredPatch;\nexports.formatPatch = formatPatch;\nexports.createTwoFilesPatch = createTwoFilesPatch;\nexports.createPatch = createPatch;\n/*istanbul ignore end*/\n\nvar\n/*istanbul ignore start*/\n_line = require(\"../diff/line\")\n/*istanbul ignore end*/\n;\n/*istanbul ignore start*/\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/*istanbul ignore end*/\n\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff =\n  /*istanbul ignore start*/\n  (0,\n  /*istanbul ignore end*/\n\n  /*istanbul ignore start*/\n  _line\n  /*istanbul ignore end*/\n  .\n  /*istanbul ignore start*/\n  diffLines\n  /*istanbul ignore end*/\n  )(oldStr, newStr, options);\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n  /*istanbul ignore start*/\n\n  var _loop = function _loop(\n  /*istanbul ignore end*/\n  i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      /*istanbul ignore start*/\n      var _curRange;\n      /*istanbul ignore end*/\n      // If we have previous context, start with that\n\n\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_curRange =\n      /*istanbul ignore end*/\n      curRange).push.apply(\n      /*istanbul ignore start*/\n      _curRange\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          /*istanbul ignore start*/\n          var _curRange2;\n          /*istanbul ignore end*/\n          // Overlapping\n\n          /*istanbul ignore start*/\n\n          /*istanbul ignore end*/\n\n          /*istanbul ignore start*/\n\n\n          (_curRange2 =\n          /*istanbul ignore end*/\n          curRange).push.apply(\n          /*istanbul ignore start*/\n          _curRange2\n          /*istanbul ignore end*/\n          ,\n          /*istanbul ignore start*/\n          _toConsumableArray(\n          /*istanbul ignore end*/\n          contextLines(lines)));\n        } else {\n          /*istanbul ignore start*/\n          var _curRange3;\n          /*istanbul ignore end*/\n          // end the range and output\n\n\n          var contextSize = Math.min(lines.length, options.context);\n          /*istanbul ignore start*/\n\n          /*istanbul ignore end*/\n\n          /*istanbul ignore start*/\n\n          (_curRange3 =\n          /*istanbul ignore end*/\n          curRange).push.apply(\n          /*istanbul ignore start*/\n          _curRange3\n          /*istanbul ignore end*/\n          ,\n          /*istanbul ignore start*/\n          _toConsumableArray(\n          /*istanbul ignore end*/\n          contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    /*istanbul ignore start*/\n    _loop(\n    /*istanbul ignore end*/\n    i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nfunction formatPatch(diff) {\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\n\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}","map":{"version":3,"sources":["C:\\Users\\Jerry\\node_modules\\diff\\src\\patch\\create.js"],"names":["options","diff","value","lines","hunks","oldRangeStart","newRangeStart","curRange","oldLine","newLine","i","current","prev","contextLines","contextSize","Math","hunk","oldStart","oldLines","newStart","newLines","oldEOFNewline","newEOFNewline","noNlBeforeAdds","oldStr","oldFileName","newFileName","oldHeader","newHeader","ret","formatPatch","structuredPatch","createTwoFilesPatch"],"mappings":"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","sourcesContent":["import {diffLines} from '../diff/line';\n\nexport function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  const diff = diffLines(oldStr, newStr, options);\n  diff.push({value: '', lines: []}); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function(entry) { return ' ' + entry; });\n  }\n\n  let hunks = [];\n  let oldRangeStart = 0, newRangeStart = 0, curRange = [],\n      oldLine = 1, newLine = 1;\n  for (let i = 0; i < diff.length; i++) {\n    const current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        const prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      }\n\n      // Output our changes\n      curRange.push(... lines.map(function(entry) {\n        return (current.added ? '+' : '-') + entry;\n      }));\n\n      // Track the updated file position\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          // Overlapping\n          curRange.push(... contextLines(lines));\n        } else {\n          // end the range and output\n          let contextSize = Math.min(lines.length, options.context);\n          curRange.push(... contextLines(lines.slice(0, contextSize)));\n\n          let hunk = {\n            oldStart: oldRangeStart,\n            oldLines: (oldLine - oldRangeStart + contextSize),\n            newStart: newRangeStart,\n            newLines: (newLine - newRangeStart + contextSize),\n            lines: curRange\n          };\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            let oldEOFNewline = ((/\\n$/).test(oldStr));\n            let newEOFNewline = ((/\\n$/).test(newStr));\n            let noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n            if ((!oldEOFNewline && !noNlBeforeAdds) || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n          hunks.push(hunk);\n\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  }\n\n  return {\n    oldFileName: oldFileName, newFileName: newFileName,\n    oldHeader: oldHeader, newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nexport function formatPatch(diff) {\n  const ret = [];\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (let i = 0; i < diff.hunks.length; i++) {\n    const hunk = diff.hunks[i];\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n    ret.push(\n      '@@ -' + hunk.oldStart + ',' + hunk.oldLines\n      + ' +' + hunk.newStart + ',' + hunk.newLines\n      + ' @@'\n    );\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nexport function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\n\nexport function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n"]},"metadata":{},"sourceType":"script"}