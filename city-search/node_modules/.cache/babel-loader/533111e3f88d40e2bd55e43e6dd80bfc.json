{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parsePatch = parsePatch;\n/*istanbul ignore end*/\n\nfunction parsePatch(uniDiff) {\n  /*istanbul ignore start*/\n  var\n  /*istanbul ignore end*/\n  options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}","map":{"version":3,"sources":["C:\\Users\\Jerry\\node_modules\\diff\\src\\patch\\parse.js"],"names":["options","diffstr","uniDiff","delimiters","list","i","index","line","header","parseFileHeader","parseHunk","JSON","fileHeader","keyPrefix","data","fileName","chunkHeaderIndex","chunkHeaderLine","chunkHeader","hunk","oldStart","oldLines","newStart","newLines","lines","linedelimiters","addCount","removeCount","operation","parseIndex"],"mappings":"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","sourcesContent":["export function parsePatch(uniDiff, options = {}) {\n  let diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    let index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if ((/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/).test(line)) {\n        break;\n      }\n\n      // Diff index\n      let header = (/^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/).exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      if ((/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/).test(line)) {\n        break;\n      } else if ((/^@@/).test(line)) {\n        index.hunks.push(parseHunk());\n      } else if (line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    const fileHeader = (/^(---|\\+\\+\\+)\\s+(.*)$/).exec(diffstr[i]);\n    if (fileHeader) {\n      let keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      const data = fileHeader[2].split('\\t', 2);\n      let fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if ((/^\".*\"$/).test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    let chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n    let hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    };\n\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    let addCount = 0,\n        removeCount = 0;\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0\n            && (i + 2 < diffstr.length)\n            && diffstr[i + 1].indexOf('+++ ') === 0\n            && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n      }\n      let operation = (diffstr[i].length == 0 && i != (diffstr.length - 1)) ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform optional sanity checking\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n"]},"metadata":{},"sourceType":"script"}