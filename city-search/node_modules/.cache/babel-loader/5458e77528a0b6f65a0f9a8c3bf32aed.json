{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.diffJson = diffJson;\nexports.canonicalize = canonicalize;\nexports.jsonDiff = void 0;\n/*istanbul ignore end*/\n\nvar\n/*istanbul ignore start*/\n_base = _interopRequireDefault(require(\"./base\"))\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_line = require(\"./line\")\n/*istanbul ignore end*/\n;\n/*istanbul ignore start*/\n\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n/*istanbul ignore end*/\n\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new\n/*istanbul ignore start*/\n_base\n/*istanbul ignore end*/\n[\n/*istanbul ignore start*/\n\"default\"\n/*istanbul ignore end*/\n](); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n/*istanbul ignore start*/\n\nexports.jsonDiff = jsonDiff;\n/*istanbul ignore end*/\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize =\n/*istanbul ignore start*/\n_line\n/*istanbul ignore end*/\n.\n/*istanbul ignore start*/\nlineDiff\n/*istanbul ignore end*/\n.tokenize;\n\njsonDiff.castInput = function (value) {\n  /*istanbul ignore start*/\n  var _this$options =\n  /*istanbul ignore end*/\n  this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v)\n  /*istanbul ignore start*/\n  {\n    return (\n      /*istanbul ignore end*/\n      typeof v === 'undefined' ? undefinedReplacement : v\n    );\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return (\n    /*istanbul ignore start*/\n    _base\n    /*istanbul ignore end*/\n    [\n    /*istanbul ignore start*/\n    \"default\"\n    /*istanbul ignore end*/\n    ].prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'))\n  );\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (\n  /*istanbul ignore start*/\n  _typeof(\n  /*istanbul ignore end*/\n  obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}","map":{"version":3,"sources":["C:\\Users\\Jerry\\node_modules\\diff\\src\\diff\\json.js"],"names":["objectPrototypeToString","Object","jsonDiff","Diff","lineDiff","undefinedReplacement","stringifyReplacer","v","JSON","canonicalize","left","right","stack","replacementStack","obj","replacer","i","canonicalizedObj","sortedKeys","key"],"mappings":"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","sourcesContent":["import Diff from './base';\nimport {lineDiff} from './line';\n\nconst objectPrototypeToString = Object.prototype.toString;\n\n\nexport const jsonDiff = new Diff();\n// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\n\njsonDiff.tokenize = lineDiff.tokenize;\njsonDiff.castInput = function(value) {\n  const {undefinedReplacement, stringifyReplacer = (k, v) => typeof v === 'undefined' ? undefinedReplacement : v} = this.options;\n\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\njsonDiff.equals = function(left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nexport function diffJson(oldObj, newObj, options) { return jsonDiff.diff(oldObj, newObj, options); }\n\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nexport function canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  let i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  let canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (typeof obj === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    let sortedKeys = [],\n        key;\n    for (key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(key)) {\n        sortedKeys.push(key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      key = sortedKeys[i];\n      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}\n"]},"metadata":{},"sourceType":"script"}