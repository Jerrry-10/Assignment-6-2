{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = _default;\n/*istanbul ignore end*/\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\n\nfunction\n/*istanbul ignore start*/\n_default\n/*istanbul ignore end*/\n(start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}","map":{"version":3,"sources":["C:\\Users\\Jerry\\node_modules\\diff\\src\\util\\distance-iterator.js"],"names":["wantForward","backwardExhausted","forwardExhausted","localOffset","start","minLine","iterator"],"mappings":";;;;;;;;AAAA;AACA;AACA;;AACe;AAAA;AAAA;AAAA;AAAA,CAAA,KAAA,EAAA,OAAA,EAAA,OAAA,EAAkC;AAC/C,MAAIA,WAAW,GAAf,IAAA;AAAA,MACIC,iBAAiB,GADrB,KAAA;AAAA,MAEIC,gBAAgB,GAFpB,KAAA;AAAA,MAGIC,WAAW,GAHf,CAAA;AAKA,SAAO,SAAA,QAAA,GAAoB;AACzB,QAAIH,WAAW,IAAI,CAAnB,gBAAA,EAAsC;AACpC,UAAA,iBAAA,EAAuB;AACrBG,QAAAA,WAAW;AADb,OAAA,MAEO;AACLH,QAAAA,WAAW,GAAXA,KAAAA;AAJkC,OAAA,CAOpC;AACA;;;AACA,UAAII,KAAK,GAALA,WAAAA,IAAJ,OAAA,EAAoC;AAClC,eAAA,WAAA;AACD;;AAEDF,MAAAA,gBAAgB,GAAhBA,IAAAA;AACD;;AAED,QAAI,CAAJ,iBAAA,EAAwB;AACtB,UAAI,CAAJ,gBAAA,EAAuB;AACrBF,QAAAA,WAAW,GAAXA,IAAAA;AAFoB,OAAA,CAKtB;AACA;;;AACA,UAAIK,OAAO,IAAID,KAAK,GAApB,WAAA,EAAoC;AAClC,eAAO,CAACD,WAAR,EAAA;AACD;;AAEDF,MAAAA,iBAAiB,GAAjBA,IAAAA;AACA,aAAOK,QAAP,EAAA;AA7BuB,KAAA,CAgCzB;AACA;;AAjCF,GAAA;AAmCD","sourcesContent":["// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nexport default function(start, minLine, maxLine) {\n  let wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      }\n\n      // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      }\n\n      // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    }\n\n    // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n  };\n}\n"]},"metadata":{},"sourceType":"script"}